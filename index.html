<html>

<head>
  <title>project3</title>
  <meta charset="UTF-8">
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
  <link rel="stylesheet" href="./index.css">

</head>
<style>
body {
  margin: 60px;
}
</style>

<body>
  <!-- <div id="container"></div> -->
  <!-- <div id="title"> Distribution of 85 Cuisine Types of Restaurants in NYC</div> -->

  <p id="projectTitle">
    <center>
      <h1>
        <font color="black" size="6">Tree Census in New York City</font>
      </h1>
    </center>
    <div style="margin-left:10px; line-height:13px;">
      <center>
        <font color="black" size="3"><br>Our dataset contains information of
          nearly every tree in New York City in 2015. You are going to explore
          the distribution and some fun facts of the trees. <br></font>
      </center>
    </div>
  </p>

<!-- first square graph visualization (recomment this to second visual) -->
<div>
  <!-- information for square graph -->
  <div>
    <center><h2>
      <font color="black" size="4"><br><br><br><br><b>Where are the trees located in New York City? </b></font>
    </h2></center>
  </div>

  <!-- square graph -->
  <svg id="treemap" width="800" height="800"></svg>

<div style="display: inline-block;">
<!-- hover information square -->
<div style="display:inline-block; margin-left: 20px;">
  <div style="width: 700px">
    <p>The treemap on the left shows how many trees are
    planted in each neighborhood. Each branch of the treemap is
    given a rectangle standing for a borough, which is then tiled with
    smaller rectangles representing neighborhoods. A leaf node's
    rectangle has an area proportional to the number of trees,and the leaf nodes are colored to show different neighborhoods.</p>
  </div>
  <p id="treemap">
    <div style="background-color:lightgrey; height: 200px; width: 700px;">
      <h4>Hover to see tree information!</h6>
      <p><b>Borough: </b><span id="borough"></span></p>
      <p><b>Neighborhood: </b><span id="name"></span></p>
      <p><b>Trees Planted: </b><span id="planted"></span></p>
      <p><b>Population Size: </b><span id="population"></span></p>
      <p><b>Most Common Trees: </b><span id="common"></span></p>
      <!-- <p><b>Least Common Trees: </b><span id="uncommon"></span></p> -->
    </div>
  </p>

<!-- neighborhood population graph (with title)-->
  <div style="display:inline-block;">
    <p>Is neighborhood population related to number of trees?</p>
  <svg id="population" height="400" width="600" font-family="sans-serif" font-size="10" style="background: #F5F5F5">
  </svg>
  </div>
</div>
</div>
</div>




  <p id="treeType">
    <center>
      <h2>
        <font color="black" size="4">
          <br><br><br><br><b>What types of trees are the most popular? </b></font>
      </h2>
      <font color="black" size="2">
        The following treemap shows the ranking of different types of trees in
        New York City. Each branch of the treemap is given a rectangle standing
        for a tree type. <br> A leaf node's
        rectangle has an area proportional to the number of trees,
        and the leaf nodes are colored to show different tree types. <br><br><br>
      </font>
    </center>
    <center><div style="background-color:lightgrey; height: 100px; width: 800px;">
      <h4>Hover to see tree information!</h6>
      <p>Tree type: <span id="type"></span></p>
      <p>Number of trees: <span id="number"></span></p>
    </div></center>
    <center><svg id="treeType" width="800" height="800"></svg></center>
  </p>
  <p>
    <center><svg id="piechart" width="800" height="800"></svg></center>
  </p>
  <p id="nycmap">
    <center>
      <h2>
        <font color="black" size="4">
          <br><br><br><br><b> Tree Census Visualization </b></font>
      </h2>
      <font color="black" size="2">
        The following map shows the distribution of trees in
        New York City. <br><br><br>
      </font>
    </center>
    <center>
      <div id="container">
        <svg id="nycmap" width="900" height="1000"></svg>
      </div>
    </center>
  </p>
  <p id="funFacts">
    <center>
      <h2>
        <font color="black" size="4">
          <br><br><br><br><b>Fun Facts </b></font>
      </h2>
      <font color="black" size="2">
        <li>The top leafiest block in each borough are: Bronx, Brooklyn, Queens, Staten Island</li>
        <li>There are 666,134 street trees on 131,488 blocks in New York City in 2015</li> <br><br><br>
      </font>
    </center>
  </p>


  <script>
    var sWidth = 1000,
      sHeight = 1000;
    // const svga = d3.select("#container")
    //                 .append("svg")
    //                 .attr("id","nycmap")
    //                 .style("width", sWidth + "px")
    //                 .style("height", sHeight + "px");
    const svga = d3.select("svg#nycmap");
    const svgid1 = "nycmap";
    const margin = {
      top: 20,
      right: 20,
      bottom: 20,
      left: 20
    };
    const mapWidth = sWidth - margin.left - margin.right;
    const mapHeight = sHeight - margin.top - margin.bottom;
    let tozoom = svga.append("g");
    // resources
    var nycsource = "nycmap.geojson";
    const requestData = async () => {

      const nycd = await d3.json(nycsource);


      var projection = d3.geoConicConformal()
        .parallels([33, 45])
        .rotate([96, -39])
        .fitSize([sWidth, sHeight], nycd);

      var path = d3.geoPath()
        .projection(projection);
      tozoom.append("g")
        .attr("id", "map")
        .selectAll("path")
        .data(nycd.features)
        .enter().append("path")
        .attr("d", path);


      const zip = await d3.json("./nyczip.geojson");

      const tree = await d3.csv("./2015_tree_no_ltlg.csv");

      const pop = await d3.csv("./zip_code_database_pop.csv");

      const zipMax = d3.max(zip.features, d => d['properties']['postalCode']);
      const zipMin = d3.min(zip.features, d => d['properties']['postalCode'])

      const zipTreeMax = d3.max(tree, d => Number(d['postcode']));
      const zipTreeMin = d3.min(tree, d => Number(d['postcode']));
      const treeMinMax = d3.extent(tree, d => Number(d['postcode']));

      var treeArray = [];
      const treeMap = new Map();
      tree.forEach((d, i) => {
        var postcode = d['postcode'];
        if (!treeMap.has(postcode)) {
          treeMap.set(postcode, true);

          treeArray.push({
            postcode: postcode,
            borough: d['borough'],
            number: 1
          })
          // cuisine.push(cui);
        } else if (treeMap.has(postcode)) {
          treeArray.find(function(e) {
            return e.postcode == postcode;
          }).number++;
        }
      });

      var entries = {
        "key": "nyc",
        "values": d3.nest()
          // .key(function(d) { return d['state']; })
          .key(function(d) {
            return d['borough'];
          })
          .key(function(d) {
            return d['nta_name'];
          })
          .rollup(function(leaves) {
            return leaves.length;
          })
          .entries(tree)
      }

      var treeData = {
        "name": "nyc",
        "children": entries.values.map(function(borough) {

          return {
            "name": borough.key,
            "children": borough.values.map(function(nta) {

              return {
                "name": nta.key,
                "value": nta.value
              };

            }) //end of map(function(region){
          };

        }) //end of map(function(major){
      }; //end of var declaration

      var type = {
        "key": "nyc",
        "values": d3.nest()
          // .key(function(d) { return d['state']; })
          .key(function(d) {
            return d['spc_common'];
          })
          .rollup(function(leaves) {
            return leaves.length;
          })
          .entries(tree)
      }

      var typeTree = {
        "name": "nyc",
        "children": type.values.map(function(spc) {
          return {
            "name": spc.key,
            "value": spc.value
          };
        })
      };

      var color = d3.scaleOrdinal(['#4daf4a','#377eb8','#ff7f00','#984ea3','#e41a1c']);
      var width = 800;
      var height = 800;
      var piesvg = d3.select("svg#piechart")
                      .append("g")
                      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

      var radius = 200;
      var pie = d3.pie()
        .value(function(d) {return d.value; })
      var data_ready = pie(typeTree.children);

      // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
      piesvg
        .selectAll('whatever')
        .data(data_ready)
        .enter()
        .append('path')
        .attr('d', d3.arc()
          .innerRadius(0)
          .outerRadius(radius)
        )
        .attr('fill', function(d,i){ return(color(i)) })
        // .attr("stroke", "black")
        // .style("stroke-width", "2px")
        .style("opacity", 0.7)


      var typeRoot = d3.hierarchy(typeTree).sum(d => d.value);

      var test = await d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/data_dendrogram_full.json");
      var root = d3.hierarchy(treeData)
        .sum(function(d) {

          return d.value;
        })

      // .sort((a, b) => b.values - a.values)

      var root2 = d3.hierarchy(test)
        .sum(function(d) {
          return d.value
        });
      const ntaMinMax = d3.extent(root.leaves(), d => Number(d['value']));
      const typeMinMax = d3.extent(typeRoot.leaves(), d => Number(d['value']));

      var ntaColorScale = d3.scaleSequential(d3.interpolateGreens).domain([ntaMinMax[0], ntaMinMax[1] / 2]);
      var typeColorScale = d3.scaleSequential(d3.interpolateYlGn).domain([typeMinMax[0], typeMinMax[1] / 2]);
      var svg = d3.select("svg#treemap");
      var svg2 = d3.select("svg#treeType");

      //array of all zip codes
      var all_zip = [];
      //array of zip code:name
      var zip_name = {};
      //array of name:zip code
      var name_zip = {};
      tree.forEach( (d, i) => {
        var zip = d.postcode
        var name = d.nta_name
        if (!all_zip.includes(zip)) {
          all_zip.push(zip);
          zip_name[zip] = name;
          name_zip[name] = zip;
        }
      });

      console.log(zip_name["11374"]);
      //array of just nyc zip codes
      nyc_pop = pop.filter(d => all_zip.includes(d['zip']));

      //array of tree frequency and population data for all neighborhoods
      var tree_and_pop = [];
      nyc_pop.forEach( (d, i) => {
        var zip = d.zip;
        var pop = d.irs_estimated_population_2015;
        var hello = treeArray.find(function(n) {
          return n.postcode == zip;
        })
        hello['pop'] = pop;
        tree_and_pop.push(hello);
      })

      //function for square mouseovers
      function mouseOnSquare(zip) {
        // console.log("in mouseOnSquare");
        // console.log(d3.select("czip_" + zip));
        d3.select("#czip_" + zip)
          .style("fill", "lightgreen")
          .attr("r", 10);
      }

      function mouseOffSquare(zip) {
        d3.select("#czip_" + zip)
          .style("fill", "green")
          .attr("r", 4);
      }

      //square treemap
      d3.treemap()
        .size([800, 800])
        .padding(2)
        (root)
      d3.select("svg#treemap").selectAll("rect")
        .data(root.leaves())
        .enter()
        .append("rect")
        .attr('x', function(d) {
          return d.x0;
        })
        .attr('y', function(d) {
          return d.y0;
        })
        .attr('width', function(d) {
          return d.x1 - d.x0;
        })
        .attr('height', function(d) {
          return d.y1 - d.y0;
        })
        .style("stroke", "black")
        .style("fill", function(d) {
          return ntaColorScale(d.value)
        })
        .on("mouseover", function(d) {
          var boroughName = d.parent.data.name;
          var nName = d.data.name;
          d3.select("#name").text(nName);
          d3.select("#planted").text(d.data.value);
          d3.select("#borough").text(boroughName);
          d3.select(this).style("stroke", "yellow").style("stroke-width", 4);
          boroughData = (tree.filter(d => d['nta_name'] === nName));
          var boroughByTree = d3.nest()
            .key(function(d) { return d.spc_common; })
            .rollup(function(v) {return v.length;})
            .entries(boroughData);

          var sorted = boroughByTree.sort(function(x,y) {
            return d3.descending(x.value, y.value);
          });
          var common = sorted.slice(0,3);
          var uncommon = sorted.slice(-3);

          d3.select("#common").text(common[0].key + " (" + common[0].value + "), " + common[1].key + " (" + common[1].value + "), " + common[2].key + " (" + common[2].value + "), ");
          // d3.select("#uncommon").text(uncommon[0].key + " (" + uncommon[0].value + "), " + uncommon[1].key + " (" + uncommon[1].value + "), " + uncommon[2].key + " (" + uncommon[2].value + "), ");

          // console.log(name_zip['Park Slope-Gowanus']);
          // console.log(nName);
          mouseOnSquare(name_zip[nName]);
        })
        .on("mouseout", function(d) {
          d3.select("#name").text("");
          d3.select("#planted").text("");
          d3.select("#common").text("");
          // d3.select("#uncommon").text("");
          d3.select("#borough").text("");
          d3.select(this).style("stroke", "black").style("stroke-width", 1);
          var nName = d.data.name;
          mouseOffSquare(name_zip[nName]);
        });
        // search to get here BOI

        //Trees by Population Graph

        //create svg data
        let svgPop = d3.select("svg#population");
        let widthPop = svgPop.attr("width");
        let heightPop = svgPop .attr("height");
        let marginPop = {top: 10, right: 10, bottom: 35, left: 100};

        //max population
        let maxPop = d3.max(tree_and_pop, function(d) {return Math.max(d['pop'])});

        //max number of trees
        let maxTrees = d3.max(tree_and_pop, function(d) {return Math.max(d['number'])});

        //population scale
        let popScale = d3.scaleLinear().domain([0,maxPop]).range([marginPop.left, widthPop-10]);

        //tree frequency scale
        let treeScale = d3.scaleLinear().domain([0, maxTrees]).range([heightPop - (marginPop.top + marginPop.bottom), 0]);

        bottomAxis = d3.axisBottom(popScale);
        svgPop.append("g").attr("class", "x axis")
          .attr("transform", "translate(0, "+(heightPop - marginPop.top - 30) +")")
          .call(bottomAxis);

        leftAxis = d3.axisLeft(treeScale);
        svgPop.append("g").attr("class", "y axis")
          .attr("transform", "translate("+(marginPop.left - 30)+", "+(marginPop.top - 5)+")")
          .call(leftAxis);

          tree_and_pop.forEach(function(d, i) {
            svgPop.append("circle")
            .attr("cx", popScale(d['pop']))
            .attr("cy", treeScale(d['number']) + marginPop.bottom + marginPop.top)
            .attr("r", 4)
            .style("fill", "green")
            .attr("id", "czip_" + d.postcode)
            .on("mouseover", function() {
                d3.select(this)
                .style("fill", "lightgreen")
                .attr("r", 10);
                d3.select("#borough").text(d.borough);
                d3.select("#name").text(zip_name[d.postcode]);
                d3.select("#planted").text("");
                d3.select("#population").text(d.pop + " People");
            })
            .on("mouseout", function(d) {
              d3.select(this)
                .style("fill", "green")
                .attr("r", 4);
                d3.select("#borough").text("");
                d3.select("#name").text("");
                d3.select("#planted").text("");
                d3.select("#population").text("");
            })
            .attr("transform", "translate(0, "+(-40) +")");
          });

          //label for x axis
          svgPop.append("text")
            // .attr("transform", "translate(" + (widthPop/2) + " ," + (heightPop + marginPop.top + 20) + ")")
            // .attr("transform", "translate(100)")
            .attr("x", widthPop/2 + 20)
            .attr("y", heightPop - 10)
            .style("text-anchor", "middle")
            .text("Population by Neighborhood");

          //label for y axis
          svgPop.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -heightPop/2 + 20)
            .attr("y", 10)
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Number of Trees");


      // tree types map
      d3.treemap()
        .size([800, 800])
        .padding(2)
        (typeRoot)
      svg2.selectAll("rect")
        .data(typeRoot.leaves())
        .enter()
        .append("rect")
        .attr('x', function(d) {
          return d.x0;
        })
        .attr('y', function(d) {
          return d.y0;
        })
        .attr('width', function(d) {
          return d.x1 - d.x0;
        })
        .attr('height', function(d) {
          return d.y1 - d.y0;
        })
        .style("stroke", "black")
        .style("fill", function(d) {
          return typeColorScale(d.value)
        })
        .on("mouseover", function(d) {
          d3.select("#type").text(d.data.name);
          d3.select("#number").text(d.data.value);
          d3.select(this).style("stroke", "yellow").style("stroke-width", 4);
        })
        .on("mouseout", function(d) {
          d3.select("#type").text("");
          d3.select("#number").text("");
          d3.select(this).style("stroke", "black").style("stroke-width", 1);
        });


      const treeNumMinMax = d3.extent(treeArray, d => d['number']);
      const ManhattanMinMax = d3.extent(treeArray, function(d) {
        if (d['borough'] == "Manhattan") {
          return d['number'];
        }
      })

      var treeColorScale = d3.scaleSequential(d3.interpolateGreens).domain([7, treeNumMinMax[1] / 5]);

      function showTrees() {
        // drawLegend(maxAll, scaleAll);
        tozoom.append("g")
          .attr("id", "nyctreemap")
          .selectAll("path")
          .data(zip.features)
          .enter().append("path")
          .attr("d", path)
          .attr("id", function(d, i) {
            return "poly" + i;
          })
          .style("fill", function(d, i) {

            // var id = d.properties.OBJECTID;
            var num = treeArray.find(function(n) {
              return n.postcode == Number(d.properties.postalCode);
            });

            if (num != undefined) {
              return treeColorScale(num.number);
            } else if (num == 0)
              return "grey"
            else if (num == undefined)
              return "grey";
            // return scale(i);
          })
          .attr("stroke-width", 0.5)
          .attr("stroke", "white")
        // .on("mouseover", function(d,i) {
        //     d3.select("#zipPopOver")
        //         .transition()
        //         .style("opacity", 1)
        //         // .style("left", "650px")
        //         // .style("top", "130px")
        //         .text(function(){
        //             // var num = cuisine.find(function(e) {
        //             // return e.cuisine == cuisineObj.cuisine
        //             // })
        //             //         .area.find(function(n) {
        //             //             return n.zip == d.properties.postalCode;
        //             //         });
        //             var num = cuisineAll.find(function(e) {
        //                 return e.zip == d.properties.postalCode;
        //             });
        //             if (num != undefined) {
        //                 return num.number + " " + " restaurants in " + " | " + num.zip;
        //             }
        //             else if (num == undefined)
        //                 return "0 "+ " restaurant in "  + " | " + d.properties.postalCode;
        //     })
        // })
        // .on("mouseout", function(){
        //     d3.select("#zipPopOver")
        //             .style("opacity", 0)
        // })

      }
      showTrees();




      // cuisine = cuisine.sort();
      function compare(a, b) {
        // Use toUpperCase() to ignore character casing
        const genreA = a.cuisine.toUpperCase();
        const genreB = b.cuisine.toUpperCase();

        let comparison = 0;
        if (genreA > genreB) {
          comparison = 1;
        } else if (genreA < genreB) {
          comparison = -1;
        }
        return comparison;
      }




      // function drawLegend(max, scaleLegend) {
      //     // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
      //     //  Credit Prof. Rz if you are basing a legend on this structure, and note performance issues

      //     const legend = d3.select("#legend");
      //     const legendWidth = legend.attr("width");
      //     const legendHeight = legend.attr("height");
      //     const barHeight = 40;
      //     const stepSize = (legendWidth-40)/(max); // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
      //     // Use minMax from step 3c, but extend range by 1 in either direction to expose more features
      //     const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([1,max]); // In this case the "data" are pixels, and we get numbers to use in colorScale
      //     const barScale = d3.scaleLinear().domain([1,max]).range([0,legendWidth-40]);
      //     var tick = 5;
      //     if (max < 5)
      //         tick = max;
      //     const barAxis = d3.axisBottom(barScale).ticks(tick,"s");
      //     d3.selectAll("#ticks").remove();
      //     d3.selectAll("#bar").remove();
      //     legend.append("g")
      //         .attr("class", "colorbar axis")
      //         .attr("id", "ticks")
      //         .attr("transform","translate("+(20)+","+(barHeight+5)+")")
      //         .call(barAxis);
      //     // d3.selectAll(".domain").attr("opacity", 0);
      //     // Draw rects of color down the bar
      //     let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")").attr("id", "bar");
      //     for (let i=0; i<legendWidth-40; i=i+stepSize) {
      //         bar.append("rect")
      //             .attr("x", i)
      //             .attr("y", 0)
      //             .attr("width", stepSize)
      //             .attr("height",barHeight)
      //             .style("fill", scaleLegend( pixelScale(i) )); // pixels => countData => color
      //     }
      //     // Put lines in to mark actual min and max of our data
      //     // bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(1)).attr("x2", barScale(1)).attr("y1", 0).attr("y1", barHeight+4);
      //     // bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(max)).attr("x2", barScale(max)).attr("y1", 0).attr("y1", barHeight+4);

      // }






      // zoom---------------------------------------------------
      // var zoom = d3.zoom()
      //   .scaleExtent([1, 10])
      //   .on("zoom", zoomed);

      // svga.call(zoom);
      // svga.call(zoom.transform, d3.zoomIdentity);

      // function zoomed() {
      //   let transform = d3.event.transform;
      //   tozoom.attr("transform", transform.toString());
      //   tozoom.select(".state-outline")
      //     .style("stroke-width", 4 / transform.k);
      //   tozoom.select(".county-outline")
      //     .style("stroke-width", 1 / transform.k);

      //   tozoom.select(".county-outline")
      //     .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
      //   tozoom.selectAll(".county")
      //     .attr("visibility", (transform.k > 3) ? "visible" : "hidden");

      // };

    };
    requestData();
  </script>
</body>

</html>
